(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{447:function(t,a,l){"use strict";l.r(a);var s=l(29),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,l=t._self._c||a;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h2",{attrs:{id:"dom操作"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#dom操作"}},[t._v("#")]),t._v(" DOM操作")]),t._v(" "),l("ol",[l("li",[l("p",[l("strong",[t._v("方式")])]),t._v(" "),l("ul",[l("li",[t._v("避免在document上直接进行频繁的DOM操作")]),t._v(" "),l("li",[t._v("使用classname代替大量的内联样式修改")]),t._v(" "),l("li",[t._v("对于复杂的UI元素，设置position为absolute或fixed")]),t._v(" "),l("li",[t._v("尽量使用css动画")]),t._v(" "),l("li",[t._v("使用requestAnimationFrame代替setInterval操作\n"),l("ul",[l("li",[t._v("其作用就是让浏览器流畅的执行动画效果。可以将其理解为专门用来实现动画效果的api，通过这个api,可以告诉浏览器某个JavaScript代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了。")]),t._v(" "),l("li",[t._v("setInterval的问题，是因为JS是单线程，每次在执行完主线程之后再进行回调执行，如果主线程执行大于定时器规定时间间隔，就很难保证流畅运行。而且这个性能也不好。")])])]),t._v(" "),l("li",[t._v("适当使用canvas")]),t._v(" "),l("li",[t._v("尽量减少css表达式的使用")]),t._v(" "),l("li",[t._v("使用事件代理")])])])]),t._v(" "),l("h2",{attrs:{id:"渲染"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#渲染"}},[t._v("#")]),t._v(" 渲染")]),t._v(" "),l("ol",[l("li",[l("p",[t._v("方式")]),t._v(" "),l("ul",[l("li",[t._v("避免重绘和回流")])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);